---
title: Как уменьшить количество записей в истории коммитов и изменить адрес электронной почты в вашем собственном коммите
origin-url: https://gitee.ru/help/articles/4198
---

**Примечание: Содержимое этого раздела взято из https://git-scm.com/book/zh/v2/Git - tool-rewrite history. Право на окончательную интерпретацию принадлежит автору этой страницы. Этот документ цитирует и форматирует содержимое только в определенной степени. Автор этого документа не имеет авторских прав на содержимое этой страницы.**

Часто при использовании Git вам по какой-либо причине может потребоваться изменить историю коммитов. Одна из замечательных особенностей Git заключается в том, что он позволяет вам принимать решения в последний момент. Вы можете решить, какие файлы включать в коммит, прежде чем отправлять содержимое промежуточной области. Вы можете отказаться от работы с определенным содержимым, используя команду stash. Вы также можете переписать прошлые коммиты, как если бы они выполнялись другим путем. Это может включать изменение порядка коммитов, изменение информации в коммитах, модификацию файлов, сжатие или разделение коммитов или полное удаление коммитов перед тем, как поделиться своей работой с другими.

В этом разделе вы узнаете, как выполнять эти очень полезные задачи, чтобы история ваших коммитов отображалась так, как вы хотите, когда делитесь своей работой с другими.

### **Изменение е последнего коммита**

Изменение вашего последнего коммита, вероятно, является наиболее распространенной операцией среди всех операций изменения истории коммитов. Для вашего последнего коммита обычно требуется сделать две вещи: изменить сообщение о фиксации или изменить моментальный снимок файлов, которые вы добавили, модифицировали и удалили.

Если вы хотите изменить только сообщение о коммите для самого последнего коммита, это очень просто:

```bash
git commit --amend
```

Выполнив эту команду, вы перейдете в текстовый редактор, где содержится ваше последнее сообщение о коммите, которое вы можете изменить. Когда вы сохраните и закроете редактор, редактор заменит самое последнее сообщение о коммите введенным вами содержимым.

Если вы уже выполнили коммит, но забыли добавить вновь созданный файл, вы можете внести изменения в моментальный снимок коммита, добавив или изменив файлы, изменив файл, а затем запустив отправку

Будьте осторожны при использовании этого метода, так как исправление изменит отправленную контрольную сумму SHA-1. Это похоже на небольшую перебазировку - не исправляйте ее, если последний коммит уже была отправлен.

### **Измените несколько сообщений о коммите**

Для внесения изменений в коммит дальше в истории коммитов необходимо использовать более сложный инструмент. В Git нет встроенного инструмента для изменения истории, но инструмент перебазирования можно использовать для перебазирования серии коммитов на основе их исходного заголовка, а не для перемещения их в новый. С помощью интерактивного инструмента перебазирования вы можете остановиться после любого коммита, который хотите изменить, а затем изменить информацию, добавить файлы или сделать все, что сочтете необходимы. Команду перебазирования можно запустить в интерактивном режиме, добавив параметр -i. Вы должны указать, как далеко назад в истории вы хотите переписать, что можно сделать, указав команде, куда вы хотите выполнить перебазировку.

Например, если вы хотите изменить сообщения о коммите для последних трех коммитов или любого из группы коммитов, передайте родительский коммит самого последнего коммита, который вы хотите изменить, в качестве аргумента команде git rebase -i, т.е. HEAD~2^ или HEAD~3.. Помните, что ~ 3 может быть легче запомнить, потому что вы пытаетесь изменить последние три фиксации; но имейте в виду, что на самом деле он определяет предыдущие четыре фиксации, т.е. родительскую фиксацию фиксации, которую вы хотите изменить:

```bash
git rebase -i HEAD~3
```

Помните, что это команда перебазирования - каждый коммит в диапазоне HEAD~3..HEAD будет перезаписан, независимо от того, измените вы информацию или нет. Не включайте никаких коммитов, которые уже были отправлены на центральный сервер - это приведет к созданию двух версий одних и тех же изменений, что приведет к путанице для других.

Выполнение этой команды выдаст вам список коммитов в текстовом редакторе, который выглядит следующим образом:

```bash
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
```

Важно отметить, что эти коммиты отображаются в обратном порядке по сравнению с обычным использованием команды log. Однократный запуск команды log покажет примерно следующее:

```bash
$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit
```

Обратите внимание на отображение в обратном порядке. Интерактивная перебазировка предоставляет вам сценарий, который она будет запускать. Он будет воспроизводить изменения каждого коммита, начиная с коммита, указанного вами в командной строке (HEAD~3), в порядке сверху вниз. Вверху указан самый старый, а не самый новый, потому что он будет заменен первым.

Вам нужно изменить сценарий, чтобы он оставался на том изменении, которое вы хотите модифицировать. Чтобы добиться этого, вам просто нужно заменить "Выбрать" перед каждым коммитом, который вы хотите изменить, на "Редактировать". Например, если вы хотите изменить только информацию о третьем коммите, вы можете изменить файл следующим образом:

```bash
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
```

Когда вы сохраняете изменения и выходите из редактора, Git отправляет вас к последнему коммиту в списке и возвращает вас в командную строку со следующим сообщением:

```bash
$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue
```

Эти инструкции подскажут вам, что именно нужно делать. Введите

```bash
git commit --amend
```

Измените сообщение о коммите и выйдите из редактора. Затем выполните

```bash
git rebase --continue
```

Эта команда автоматически применит два других коммита, после чего будет завершена. Если вам нужно изменить более одного коммита, выбранного для редактирования, вам будет необходимо изменить каждый из них по отдельности.

### **Изменить порядок  коммитов**.

Интерактивную перебазировку также можно использовать для изменения порядка или полного удаления коммитов. Если вы хотите удалить коммит 'added cat-file', а затем изменить их порядок, введённый двумя другими коммитами, вы можете использовать скрипт rebase следующим образом:

```bash
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
```

Внесите следующие изменения:

```bash
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
```

Когда вы сохраняете изменения и выходите из редактора, Git возвращает вашу ветку к родительским коммитам этих коммитов, применяет 310154e, затем применяет f7f3f6d и, наконец, останавливается. Собственно говоря, он изменяет порядок этих коммитов и полностью удаляет коммит 'added cat-file'.

### **Сжать и отправить**

Используя интерактивный инструмент rebase, серию коммитов также можно сжать в один коммит. Полезные инструкции приведены в информации о rebase.

```bash
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
```

Если вместо 'pick' или 'edit' вы укажете 'squash', Git применит оба изменения и объединит сообщения о коммитах. Таким образом, если вы хотите, чтобы эти три коммита стали одним коммитом, вы можете изменить скрипт следующим образом:

```bash
pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file
```

При сохранении и выходе из редактора Git применяет все три модификации и переводит вас в редактор для объединения трёх сообщений о коммитах.

```bash
# This is a combination of 3 commits.
# The first commit's message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file
```

После сохранения вы получите коммит, включающий все изменения первых трех коммитов.

### **Разделить коммит**

Разделение коммита отменяет коммит, а затем частичному разбиению на этапы и повторению фиксации несколько раз, пока не будет достигнуто нужное количество коммитов. Например, вы хотите разделить средний из трёх коммитов. Вы хотите разделить его на два коммита: первый - "обновленное форматирование файла README", а второй - "добавленная жалоба" вместо первоначального "обновить форматирование файла README и добавить жалобу". Это можно сделать, изменив скрипт rebase -i и поменяв инструкцию разделяемого коммита на 'edit'.

```bash
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
```

Затем, когда скрипт введет вас в командную строку, сбросьте этот коммит и извлеките изменения из сброса. Создайте из него несколько коммитов. Когда вы сохраните изменения и выйдете из редактора, Git выполнит следующую команду

```bash
git reset HEAD^
git add README
git commit -m 'updated README formatting'
git add lib/simplegit.rb
git commit -m 'added blame'
git rebase --continue
```

Git применит последнюю фиксацию (a5f4a0d) в скрипте, и история примет следующий вид:

```bash
git log -4 --pretty=format:"%h %s"

1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
```

Еще раз: эти изменения изменяют контрольную сумму SHA-1 всех коммитов в списке, поэтому убедитесь, что коммиты в списке не были перенесены в общий репозиторий.

### **Термоядерная опция: команда filter-branch**

Есть еще один вариант перезаписи истории, которым вы можете воспользоваться если вы хотите переписать большое количество коммитов с помощью скрипта - например, полностью изменив свой адрес электронной почты или удалив файл из каждого коммита. Это команда filter-branch, которая может переписать большое количество коммитов в истории. Вам не следует использовать ее, если только ваш репозиторий не был опубликован и никто другой не основывал свою работу на коммитах, которые необходимо переписать. Однако это может быть очень полезно. Вы ознакомитесь с несколькими распространенными вариантами использования, которые дадут вам представление о том, где его можно использовать.

### **Удаление файла из всех коммитов**

Такое часто случается. Кто-то по неосторожности создал коммит большого двоичного файла с помощью git add, и вы хотите удалить его отовсюду. Возможно, случайно создан коммит файла с паролем, но он нужен вам для проекта с открытым исходным кодом. Команда filter-branch - это инструмент, который можно использовать для очистки всей истории коммитов. Чтобы удалить файл с именем passwords.txt из всей истории коммитов, вы можете использовать с filter-branch опцию --tree-filter.

```bash
git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten
```

--параметр древовидного фильтра запускает указанную команду после проверки каждого коммита репозитория и повторного подтверждения результатов. В этом примере вы удаляете файл с именем passwords.txt из каждого моментального снимка, независимо от его существования. Если вы хотите удалить все случайные файлы резервных копий редактора, вы можете запустить команду типа git filter-branch --tree-filter 'rm -f *~' HEAD.

Наконец, вы увидите, что дерево Git переписано, а коммиты перемещены. Обычно рекомендуется делать это в тестовой ветке, а затем, когда вы будете готовы и удовлетворены конечным результатом, выполнить полный сброс в основной ветке. Чтобы заставить filter-branch выполняться во всех ветвях, вы можете передать команде параметр --all.

### **Сделайте поддиректорию новой корневой директорией**

Предполагая, что он был импортирован из другой системы управления исходным кодом и есть несколько пустых поддиреткорий (trunk, tags и т.д.). Если вы хотите, чтобы поддиректория trunk была новой корневой директорией репозитория для каждого коммита, filter-branch может помочь вам сделать это.

```bash
$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten
```

Теперь новая корневая директория репозитория является магистральной поддиректорией. Git автоматически удалит все коммиты, которые не влияют на поддиректорию.

### **Глобальное изменение адреса электронной почты**

Еще один распространенный сценарий заключается в том, что, начиная работать, вы забываете запустить "git config", чтобы задать свое имя и адрес электронной почты, или вы хотите открыть исходный код проекта и заменить все свои рабочие адреса электронной почты на личный адрес электронной почты. В любом случае, вы также можете использовать 'filter-branch' для изменения адресов электронной почты в нескольких коммитах одновременно. Будьте осторожны, изменяйте только свой собственный адрес электронной почты, поэтому используйте '--commit-filter':

```bash
git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
```

Это приведет к повторению и перезаписи каждого коммита, в который будет включен ваш новый адрес электронной почты. Поскольку коммиты включают контрольную сумму SHA-1 своих родительских коммитов, эта команда изменит в вашей истории контрольную сумму SHA-1 всех коммитов, а не только тех, в которых адрес электронной почты совпадает с указанным.