---
title: Как уменьшить количество историй коммитов и изменить адрес электронной почты в вашем коммите
authors:
  - name: No Mo
    url: https://gitee.ru/normalcoder
origin-url: https://gitee.ru/help/articles/4198
---

Примечание: Содержимое этого раздела взято с сайта <https://git-scm.com/book/zh/v2/Git>-Tools-Rewriting History. Окончательное право интерпретации принадлежит автору этой страницы. Данный документ лишь в некоторой степени цитирует и форматирует содержание. Автор этого документа не имеет авторских прав на содержание этой страницы.

Часто при использовании Git вам по какой-либо причине может понадобиться исправить историю коммитов. Одна из замечательных особенностей Git заключается в том, что он позволяет принимать решения в последний момент. Прежде чем поделиться своей работой с другими, вы можете решить, какие файлы включить в коммит непосредственно перед отправкой коммита содержимого этапа. Вы можете отказаться от работы с определённым содержимым с помощью команды stash. Вы также можете переписать прошлые коммиты так, как будто они были созданы по-другому. Это может включать изменение порядка коммита, изменение информации в коммитах, модификацию файлов, сжатие или разделение коммитов или их полное удаление.

В этом разделе вы узнаете, как выполнить эти очень полезные задачи, чтобы ваша история коммитов отображалась так, как нужно, когда вы делитесь своей работой с другими.

### Изменение последнего коммита

Изменение последнего коммита - одна из самых распространённых операций, выполняемых при работе с Git. Для последнего коммита вы обычно хотите сделать две вещи: изменить сообщение о коммите или изменить снимки файлов, которые вы добавили, изменили и удалили.

Если вы просто хотите изменить сообщение о последнем коммите, это очень просто:

```bash
git commit --amend
```

В результате вы перейдете в текстовый редактор, содержащий ваше последнее сообщение о коммите, которое вы можете изменить. Когда вы сохраните и закроете редактор, он заменит последнее сообщение о коммите введенным вами содержимым.

Если вы уже сделали коммит, но забыли добавить вновь созданный файл, вы можете внести изменения в снимок коммита, добавив или изменив файлы. Если изменить файл, а затем выполнить `git add` или `git rm` для отслеживаемого файла, а затем `git commit --amend`, то текущая область хранения будет удалена и использована в качестве снапшота для нового коммита.

При использовании этой техники будьте осторожны, так как при изменении будет изменена переданная контрольная сумма SHA-1. Это похоже на небольшой rebase. Не вносите поправки, если последний коммит уже был вытолкнут.

### Изменение нескольких сообщений о коммите

Чтобы изменить коммит, который находится дальше в истории коммитов, необходимо использовать более сложный инструмент. В Git нет инструмента для изменения истории, вы можно использовать инструмент rebase для изменения серии коммитов на основе их исходного состояния.

Например, в случае необходимости изменить сообщения последних трёх коммитов или любого другого из группы коммитов, передайте родительский коммит самого последнего коммита, который вы хотите изменить, в качестве аргумента команде git rebase -i, то есть HEAD~2^ или HEAD~3. Помните, что ~3 может быть легче запомнить, потому что вы пытаетесь изменить последние три коммита; но имейте в виду, что на самом деле он указывает на предыдущие четыре коммита, то есть, и на родительский коммит изменяемого вами коммита:

```bash
git rebase -i HEAD~3
```

Ещё раз напомним, что это команда rebase - каждый коммит в диапазоне HEAD~3...HEAD будет переписан, независимо от того, изменяете ли вы информацию. Не включайте коммиты, которые уже были отправлены на центральный сервер - это создаст две версии одного и того же изменения, что запутает других.

Выполнив эту команду, вы получите список коммитов в текстовом редакторе, который выглядит следующим образом:

```bash
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
```

It should be noted that the order displayed in these commits is reversed compared to the normal use of the log command. Running the log command once, you will see something like this:

```bash
git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit
```

Обратите внимание на отображение в обратном порядке. Интерактивный rebase предоставляет вам скрипт, который будет запущен. Он воспроизведёт изменения каждого коммита от самого старого к самому новому, начиная с коммита, который вы указали в командной строке (HEAD~3). Он перечисляет самый старый, а не самый новый коммит вверху, потому что именно он будет воспроизведён первым.

Вам нужно изменить скрипт, чтобы он оставался на изменении, которое вы хотите изменить. Для этого просто замените 'pick' на 'edit' перед каждым коммитом, который вы хотите изменить. Например, если вы хотите изменить только третье сообщение коммита, вы можете изменить файл следующим образом:

```bash
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
```

Когда вы сохраняете изменения и выходите из редактора, Git возвращает вас к последнему коммиту в списке и возвращает вас в командную строку со следующим сообщением:

```bash
$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
Теперь вы можете внести изменения в коммит, используя

       git commit --amend

Когда вы будете удовлетворены своими изменениями, выполните команду

       git rebase --continue
```

Эти инструкции подскажут вам, что именно нужно делать. Введите

```bash
git commit --amend
```

Измените сообщение о коммите и выйдите из редактора. Затем выполните

```bash
git rebase --continue
```

Эта команда автоматически применит два других коммита, и всё будет готово. Если вам нужно изменить несколько коммитов 'pick' на 'edit', вам нужно изменить каждый из них отдельно.

### Упорядочить коммиты

Вы также можете использовать интерактивный rebase для переупорядочивания или полного удаления коммитов. Если вы хотите удалить коммит 'added cat-file', а затем изменить порядок, введённый двумя другими коммитами, вы можете переписать скрипт rebase следующим образом:

```bash
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
```

Измените его на этот:

```bash
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
```

Когда вы сохраняете и выходите из редактора, Git возвращает вашу ветку к родительскому коммиту этих коммитов, применяет 310154e, затем применяет f7f3f6d и, наконец, останавливается. На самом деле порядок этих коммитов был изменён, а коммит 'added cat-file' был полностью удалён.

### Сжатый коммит

Вы также можете сжать серию коммитов в один коммит с помощью интерактивного инструмента rebase. Скрипт предоставляет полезные инструкции в информации о rebase.

```bash
#
# Команды:
# p, pick = использовать коммит
# r, reword = использовать коммит, но редактировать сообщение о коммите
# e, edit = использовать коммит, но остановить для внесения поправок
# s, squash = использовать коммит, но объединить с предыдущим коммитом
# f, fixup = как "squash", но отбрасываем сообщение журнала этого коммита
# x, exec = выполнить команду (оставшуюся часть строки) с помощью оболочки
#
# Эти строки могут быть переупорядочены; они выполняются сверху вниз.
#
# Если вы удалите здесь строку, то этот коммит будет потерян.
#
# Однако, если вы удалите все, rebase будет прерван.
#
# Обратите внимание, что пустые коммиты комментируются
```

Если вместо 'pick' или 'edit' указано 'squash', Git применит изменения обоих коммитов и объединит сообщения коммита вместе. Поэтому, если вы хотите, чтобы эти три коммита были одним коммитом, вы можете изменить сценарий следующим образом:

```bash
pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file
```

Когда вы сохраняете и выходите из редактора, Git применяет все три модификации и возвращает вас в редактор, чтобы объединить три сообщения коммита:

```bash
# Это комбинация из 3 коммитов.
# Сообщение первого коммита следующее:
changed my name a bit

# Это второе сообщение о коммите:

updated README formatting and added blame

# Это 3-е сообщение о коммите:

added cat-file
```

После сохранения у вас будет коммит, содержащий все изменения из предыдущих трех коммитов.

### Разделение коммитов

Разделение коммитов отменяет коммит, а затем частично выполняет коммит несколько раз, пока не будет достигнуто нужное количество коммитов. Например, если вы хотите разделить средний коммит из трёх коммитов. Вы хотите разделить его на два коммита: первый - "обновить форматирование README", а второй - "добавить вину" вместо оригинального "обновить форматирование README и добавить вину". Это можно сделать, изменив скрипт rebase -i и поменяв инструкцию разделяемого коммита на 'edit'.

```bash
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
```

Затем, когда скрипт переведёт вас в командную строку, сбросьте этот коммит и получите изменения из сброса. Создайте из него несколько коммитов. Когда вы сохранитесь и выйдете из редактора, Git переведёт вас на родительский коммит первого коммита в списке, применит первый коммит (f7f3f6d), применит второй коммит (310154e), а затем переведёт вас в командную строку. Там вы можете выполнить смешанный сброс для этого коммита с помощью команды 'git reset HEAD^', которая фактически отменит этот коммит и снимет с хранения изменённые файлы. Теперь вы можете перемещать и фиксировать файлы, пока не получите несколько коммитов, а затем выполнить команду 'git rebase --continue', когда всё будет готово.

```bash
git reset HEAD^
git add README
git commit -m 'updated README formatting'
git add lib/simplegit.rb
git commit -m 'added blame'
git rebase --continue
```

Git применяет последний коммит (a5f4a0d) в скрипте. История выглядит следующим образом:

```bash
$ git log -4 --pretty=format:"%h %s"

1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
```

Опять же, эти изменения изменили контрольную сумму SHA-1 всех коммитов в списке, поэтому убедитесь, что ни один из коммитов в списке еще не был выложен в общий репозиторий.

## Опция уровня ядера: filter-branch

Существует ещё одна опция для переписывания истории, если вы хотите переписать большое количество коммитов с помощью скрипта, вы можете использовать её - например, глобально изменить свой адрес электронной почты или удалить файл из каждого коммита. Эта команда - filter-branch, которая может переписать большое количество коммитов в истории. Её не следует использовать, если только ваш репозиторий не был опубликован и никто другой не основывал свою работу на коммитах, которые нужно переписать. Тем не менее, она может быть очень полезной. Вы познакомитесь с несколькими распространёнными случаями использования, что даст вам представление о том, где его можно применить.

### Удалить файл из каждого коммита

Такое часто случается. Кто-то по неосторожности коммитит огромный бинарный файл через git add . и вы хотите удалить его отовсюду. Возможно, вы случайно закоммитили файл, содержащий пароль, но хотите, чтобы он был с открытым исходным кодом. filter-branch

```bash
$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten
```

Опция --tree-filter запускает указанную команду после проверки каждого коммита репозитория и повторного коммита с результатами. В этом примере вы удаляете файл passwords.txt из каждого снапшота, независимо от его существования. Если вы хотите удалить все случайные резервные файлы редактора, вы можете выполнить команду git filter-branch --tree-filter 'rm -f \*~' HEAD.

Наконец, вы увидите, как Git переписывает деревья и коммиты, а затем перемещает указатели веток. Обычно это хорошо делать в тестовой ветке, а затем жестко сбросить мастер-ветку, когда вы решите, что конечный результат - это то, что вы действительно хотите. Чтобы заставить filter-branch работать на всех ветках, вы можете передать команде опцию --all.

### Сделать подкаталог новым корневым каталогом

Предположим, что он был импортирован из другой системы контроля исходного кода и имеет несколько бессмысленных подкаталогов (trunk, tags и т. д.). Если вы хотите сделать подкаталог trunk новым корневым каталогом репозитория для каждого коммита, filter-branch поможет вам это сделать.

```bash
$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten
```

Теперь новым корневым каталогом репозитория будет подкаталог trunk. Git автоматически удалит все коммиты, которые не влияют на подкаталог.

### Глобальное изменение адреса электронной почты

Другой распространенный сценарий - когда вы забыли запустить 'git config', чтобы задать свое имя и адрес электронной почты перед началом работы, или когда вы хотите открыть исходный код проекта и изменить все рабочие адреса электронной почты на свой личный адрес. В любом случае, вы также можете использовать 'filter-branch' для изменения адресов электронной почты в нескольких коммитах одновременно. Будьте внимательны, чтобы изменить только свой собственный адрес электронной почты, поэтому используйте '--commit-filter':

```bash
git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
```

В результате каждый коммит будет переписан с учётом вашего нового адреса электронной почты. Поскольку коммиты включают контрольную сумму SHA-1 своих родительских коммитов, эта команда изменит каждый коммит в вашей истории.