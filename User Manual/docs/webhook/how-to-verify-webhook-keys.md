---
title: Верификация и алгоритм верификации ключа вебхука
authors:
  - name: No Mo
    url: https://gitee.ru/normalcoder
origin-url: https://gitee.ru/help/articles/4290
---

## Введение в подпись вебхука

Вебхук Gitee поддерживает безопасную аутентификацию с использованием ключа.

Пользователи могут настроить собственный секретный ключ вебхука, подписывать содержимое запроса при его отправке, и сервер может проверить полученный запрос, подписав его тем же секретным ключом, чтобы подтвердить его целостность и надежность. Секретный ключ вебхука существует только на Gitee и сервере, и не раскрывается во время передачи по сети.

> В сравнении с верификацией пароля верификация подписи может эффективно избежать проблем безопасности, вызванных утечкой паролей вебхука во время передачи по сети.

## Алгоритм генерации подписи вебхука (Ссылка)

Если вебхук использует подпись, в заголовке запроса будет включен X-Gitee-Token с сгенерированной подписью в качестве значения. Алгоритм подписи следующий:

### Описание параметров подписи

| Параметр | Описание |
| --------- | --------------------------------------------------------------- |
| отметка времени | Текущая отметка времени, в миллисекундах. Разница между временем вызова запроса не должна превышать 1 час, она должна быть отправлена вместе с ключом при создании запроса
 |
| секретный ключ  | Ключ подписи, строка, начинающаяся с SEC, отображаемая ниже раздела подписи на странице настроек безопасности бота |

- Шаг 1: Используйте отметку времени + "
" + секретный ключ как строку подписи и вычислите подпись с использованием алгоритма HmacSHA256.
- Шаг 2: Кодируйте результат, полученный выше, в Base64.
- Шаг 3: Примените URL-кодирование к полученному результату (используя набор символов UTF-8), чтобы получить конечную подпись.

Шаг 4: Объедените отметку времени и значение подписи, полученное на предыдущих шагах, с URL.

## Пример кода вычисления подписи 

Пример кода вычисления подписи  (Java)

```java
Long timestamp = System.currentTimeMillis();
String stringToSign = timestamp + "
" + secret;
Mac mac = Mac.getInstance("HmacSHA256");
mac.init(new SecretKeySpec(secret.getBytes("UTF-8"), "HmacSHA256"));
byte[] signData = mac.doFinal(stringToSign.getBytes("UTF-8"));
return URLEncoder.encode(new String(Base64.encodeBase64(signData)),"UTF-8");
```

Пример кода вычисления подписи  (Python)

```python
#python 2.7
import time
import hmac
import hashlib
import base64
import urllib

timestamp = long(round(time.time() * 1000))
secret = 'this is secret'
secret_enc = bytes(secret).encode('utf-8')
string_to_sign = '{}
{}'.format(timestamp, secret)
string_to_sign_enc = bytes(string_to_sign).encode('utf-8')
hmac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()
sign = urllib.quote_plus(base64.b64encode(hmac_code))
print(timestamp)
print(sign)
```